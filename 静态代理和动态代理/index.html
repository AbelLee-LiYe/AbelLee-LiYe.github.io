<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Abel"><title>静态代理和动态代理 · Abel Lee</title><meta name="description" content="静态代理静态代理很简单，举个例子：
我们日常生活中，都要找人解决各种各样问题。
我们先不管到底解决的是什么问题，我们同意写成do()。
静态代理的一个重要的地方就是需要固定的接口。


大体流程是这样的：
平时我们找人做事，我们需要直接找到这个人，但是个人的经历非常有限，而且能做的事情非常少"><meta name="keywords" content="Abel,Abel Lee,Abel Blog"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" href="../images/favicon.ico"><link rel="stylesheet" href="../css/style.css"><link rel="stylesheet" href="../css/blog_basic.css"><link rel="stylesheet" href="../css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="../js/jquery.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><div class="main"><div class="full-page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="full-content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>静态代理和动态代理</a></h3></div><div class="post-content"><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a><a href="#静态代理" title="静态代理"></a>静态代理</h1><p>静态代理很简单，举个例子：</p>
<p>我们日常生活中，都要找人解决各种各样问题。</p>
<p>我们先不管到底解决的是什么问题，我们同意写成do()。</p>
<p>静态代理的一个重要的地方就是需要固定的接口。</p>
<a id="more"></a>

<p>大体流程是这样的：</p>
<p>平时我们找人做事，我们需要直接找到这个人，但是个人的经历非常有限，而且能做的事情非常少。</p>
<p>比如我们在这个人的接口上面定义了他能做某件事，所以这个人就只能做某件事，为什么不能干别的，因为我们没定义。因为定义了，就违反了OOP编程的概念。</p>
<p>我再把这个例子具体一点，你也许就能明白许多。</p>
<p>比如我们定义一个Person接口，它的唯一方法是do();<br>再定义一个实现类，歌手，然后实现这个方法，我们告诉这个歌手，你只能唱歌。</p>
<p>这个时候，当我们想调用歌手的时候。发现歌手很忙。而且他只能唱歌。毕竟术业有专攻。这个时候我们怎么办。</p>
<p>我们需要给这个歌手一个经纪人。我们这里称为代理类。</p>
<p>然后我们就以后不直接找这个歌手了，我们直接找这个经纪人，也就是这个代理类，歌手负责唱歌，代理类负责做所有其它的事情。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singer</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="meta">@Override</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">do</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> sout(<span class="string">"我能唱歌！"</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> Person person;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(Person person)</span></span>&#123;  </span><br><span class="line"> <span class="keyword">this</span>.person = person  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 加这么多 o 就是想表面，名字不是一样的。但是do很恰当。  </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dooooo</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> <span class="comment">// do something!  </span></span><br><span class="line">  </span><br><span class="line"> person.<span class="keyword">do</span>();  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// do something!  </span></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span></span>&#123;  </span><br><span class="line"> psvm&#123;  </span><br><span class="line"> PersonProxy personproxy = <span class="keyword">new</span> PersonProxy(<span class="keyword">new</span> Singer);  </span><br><span class="line">  </span><br><span class="line"> personproxy.dooooo();  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在你懂了吗？ 当然在代码里面是不能用 do 这个关键字的。</p>
<p>当我们想用 歌手的时候就传歌手，就很自由。</p>
<p>静态代理对于一个 经常敲代码的人来说， 即使没有学过，也会很自然的写出来，但是静态代理的缺点就是，很难扩展。</p>
<p>比如：我们要在歌手唱歌之前和后，不断变换业务，那会怎么样？你是选择做超多的代理类还是？如果要复用呢？你又如何做？</p>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a><a href="#动态代理" title="动态代理"></a>动态代理</h1><p>使用动态代理，我们实现一个接口。</p>
<p>InvocationHandler 顾名思义： 调用处理器</p>
<p>流程控制都由它处理。</p>
<p>它长这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object\[\] args)</span>  </span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> Throwable</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得刚学动态代理的时候，反射和设计模式，总不能很好的互相适应，每次都感觉摸不到知识。后来通过不断的看，总算把它掌握了。</p>
<p>参数的名字：</p>
<ol>
<li>proxy：调用此方法的代理实例</li>
<li>method：就是反射那个Method类，在这里就是正在调用的方法</li>
<li>args：这个是在这个方法内调用方法时方法的参数</li>
<li>返回值：这个返回值，真的是，看了好多篇博文，大家真的是非常默契，点到即止，一到这里就没了。所以我特地查了API，找到了答案</li>
</ol>
<p>原文是：the value to return from the method invocation on the proxy instance. If the declared return type of the interface method is a primitive type, then the value returned by this method must be an instance of the corresponding primitive wrapper class; otherwise, it must be a type assignable to the declared return type. If the value returned by this method is {@code null} and the interface method’s return type is primitive, then a {@code NullPointerException} will be thrown by the method invocation on the proxy instance. If the value returned by this method is otherwise not compatible with the interface method’s declared return type as described above,a {@code ClassCastException} will be thrown by the method invocation on the proxy instance.</p>
<p>中文意思是：从代理实例上的方法调用返回的值。如果接口方法声明的返回类型是原始类型，那么该方法返回的值必须是对应原始包装类的实例;否则，它必须是可分配给声明的返回类型的类型。如果此方法返回的值为{@code null}，且接口方法的返回类型为原始类型，则方法调用将在代理实例上抛出{@code NullPointerException}。如果此方法返回的值与上述接口方法声明的返回类型不兼容，则方法调用将在代理实例上抛出{@code ClassCastException}。</p>
<p>懂了没？</p>
<p>然后我们还需要一个 Proxy 类</p>
<p>这个类的作用就是：动态生成代理类和对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,  </span></span></span><br><span class="line"><span class="function"><span class="params"> Class&lt;?&gt; [] interfaces,  </span></span></span><br><span class="line"><span class="function"><span class="params"> InvocationHandler h)</span>  </span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>

<p>这个类 需要传入 类加载器，要操作的接口，和 你定义的调用处理器。 并返回一个 代理对象。</p>
<p>来，我们直接上代码：<br>我们把do改成doSomething，你们可以直接复制代码进行测试，我推荐这么做，因为动态代理，稍难理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singer</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="meta">@Override</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;  </span><br><span class="line"> sout(<span class="string">"我能唱歌！"</span>);  </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 注意这里我不采用名字 PersonProxy，用 PersonHandler  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span> Person person;  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(Person person)</span></span>&#123;  </span><br><span class="line"> <span class="keyword">this</span>.person = person  </span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 我们会实现这个方法  </span></span><br><span class="line"> <span class="meta">@Override</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object\[\] args)</span> </span>&#123;  </span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 这个方法就是控制流程了，你可以在这里做一些事情。  </span></span><br><span class="line"> <span class="comment">// do something  </span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">//这个方法就是被代理的类内的方法。  </span></span><br><span class="line"> method.invoke(person, args);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// do something  </span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 因为原始的方法没有返回值，所以我们这里返回null  </span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;  </span><br><span class="line">    </span><br><span class="line"> psvm&#123;  </span><br><span class="line"> <span class="comment">// 把要处理的对象搞进来  </span></span><br><span class="line"> Singer singer = <span class="keyword">new</span> Singer();  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 此类的处理器。多态真的太棒了。然后把要处理的对象传进去。  </span></span><br><span class="line"> PersonHandler personHandler = <span class="keyword">new</span> PersonHandler(singer);  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 这里我们会先做个代理对象  </span></span><br><span class="line"> <span class="comment">// 第一个参数：类加载器，这里我们随便选个默认加载器  </span></span><br><span class="line"> <span class="comment">// 第二个参数：处理类的接口，这里就是 Person  </span></span><br><span class="line"> <span class="comment">// 第三个参数：我们定义的处理器，这里就是 personHandler   </span></span><br><span class="line"> Person proxy = (Person)Peoxy.newProxyInstance(  </span><br><span class="line"> ClassLoader.getSystemClassLoader(),  </span><br><span class="line"> <span class="keyword">new</span> Class\[\]&#123;Person<span class="class">.<span class="keyword">class</span>&#125;,  </span></span><br><span class="line"><span class="class"> <span class="title">personHandler</span>   </span></span><br><span class="line"><span class="class"> )  </span></span><br><span class="line"><span class="class">  </span></span><br><span class="line"><span class="class"> // 这里我们就可以调用包裹了<span class="title">Singer</span>所有方法的代理类，  </span></span><br><span class="line"><span class="class"> // 这个代理类 可以 调用 <span class="title">Singer</span> 的所有方法，  </span></span><br><span class="line"><span class="class"> // 因为我们就定义了一个 <span class="title">doSomething</span>，所以我们就调用了一个方法，  </span></span><br><span class="line"><span class="class"> // 但是这个方法就是：上面所谓的流程。  </span></span><br><span class="line"><span class="class"> // 你可以在 <span class="title">handler</span> 里面，进行在这个方法上面下面干你想做的事情。  </span></span><br><span class="line"><span class="class"> // 这个就是动态代理了。  </span></span><br><span class="line"><span class="class"> <span class="title">proxy</span>.<span class="title">doSomething</span>()</span>;  </span><br><span class="line">    </span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他们最大的区别就是，静态代理只代理一个类，<br>而动态代理可以代理，一个接口下的多个类。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-12-23</span><i class="fa fa-tag"></i><a class="tag" href="/tags/java/" title="java">java </a><a class="tag" href="/tags/设计模式/" title="设计模式">设计模式 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="../%E5%93%8D%E4%BA%86%E8%AE%B8%E4%B9%85%E7%9A%84%E8%8A%B1%E5%92%8C%E7%82%AE/" title="响了许久的花和炮">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="../spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="spring学习笔记">下一篇</a></li></ul></div><script src="../js/visitors.js"></script></div></div></div></div><script src="../js/jquery-migrate-1.2.1.min.js"></script><script src="../js/jquery.appear.js"></script><script src="../js/add-bookmark.js"></script><script src="../js/baidu-tongji.js"></script></body></html>